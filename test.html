<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js GLB Frame Overlay with Responsive Expanders</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

// Camera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
camera.position.set(0, 0, 5);
scene.add(camera);

// (Optional) a simple world object so you can see the frame “framing” something
const world = new THREE.Group();
scene.add(world);
{
  const g = new THREE.TorusKnotGeometry(0.7, 0.25, 180, 36);
  const m = new THREE.MeshStandardMaterial({ metalness:0.3, roughness:0.4, color:0x66aaff });
  const mesh = new THREE.Mesh(g, m);
  world.add(mesh);
  const l1 = new THREE.DirectionalLight(0xffffff, 1.0); l1.position.set(1,1,1); scene.add(l1);
  const l2 = new THREE.AmbientLight(0xffffff, 0.4); scene.add(l2);
}

// Frame overlay group that “sticks” to camera
const frameGroup = new THREE.Group();
// Keep it just in front of the camera’s near plane
const frameDistance = 0.7; // adjust to your liking
frameGroup.position.set(0, 0, -frameDistance);
camera.add(frameGroup);

// Loader
const loader = new GLTFLoader();

// Map names to file paths
const files = {
  // corners
  "corner-top-left":          "corner-top-left.glb",
  "corner-top-right":         "corner-top-right.glb",
  "corner-bottom-left":       "corner-bottom-left.glb",
  "corner-bottom-right":      "corner-bottom-right.glb",
  // mains
  "main-top":                 "main-top.glb",
  "main-bottom":              "main-bottom.glb",
  "main-left":                "main-left.glb",
  "main-right":               "main-right.glb",
  // horizontal expanders (top/bottom)
  "top-left-expander":        "top-left-expander.glb",
  "top-right-expander":       "top-right-expander.glb",
  "bottom-left-expander":     "bottom-left-expander.glb",
  "bottom-right-expander":    "bottom-right-expander.glb",
  // vertical expanders (left/right)
  "left-top-expander":        "left-top-expander.glb",
  "left-bottom-expander":     "left-bottom-expander.glb",
  "right-top-expander":       "right-top-expander.glb",
  "right-bottom-expander":    "right-bottom-expander.glb",
};

// Buckets for behavior
const cornerKeys = [
  "corner-top-left","corner-top-right","corner-bottom-left","corner-bottom-right"
];
const mainKeys = ["main-top","main-bottom","main-left","main-right"];
const horizontalExpanderKeys = [
  "top-left-expander","top-right-expander","bottom-left-expander","bottom-right-expander"
];
const verticalExpanderKeys = [
  "left-top-expander","left-bottom-expander","right-top-expander","right-bottom-expander"
];

// Storage for meshes and their base transforms/bboxes
const parts = {}; // name -> { object, basePos, baseScale, bbox, stretchAxis, seamLock }

// Utility: compute world-space bbox of a loaded scene
function getWorldBBox(obj) {
  const bbox = new THREE.Box3().setFromObject(obj);
  return bbox;
}

// Utility: record base transform and bbox
function registerPart(name, object, stretchAxis=null, seamLock="inner") {
  object.updateMatrixWorld(true);
  const bbox = getWorldBBox(object);
  parts[name] = {
    object,
    basePos: object.position.clone(),
    baseScale: object.scale.clone(),
    bbox,
    stretchAxis, // "x" or "y" or null
    seamLock,    // "inner" side stays fixed when scaling
  };
  frameGroup.add(object);
}

// Load all parts
async function loadAll() {
  const entries = Object.entries(files);
  await Promise.all(entries.map(async ([key, url]) => {
    const gltf = await loader.loadAsync(url);
    // If GLBs contain multiple nodes, group them
    const container = new THREE.Group();
    gltf.scene.traverse(node => {
      if (node.isMesh) {
        node.castShadow = false;
        node.receiveShadow = false;
      }
    });
    container.add(gltf.scene);
    container.position.set(0,0,0); // origins already at frame center; keep as-is
    container.rotation.set(0,0,0);
    container.scale.set(1,1,1);

    // Decide stretch axis
    let stretchAxis = null;
    if (horizontalExpanderKeys.includes(key)) stretchAxis = "x";
    if (verticalExpanderKeys.includes(key))   stretchAxis = "y";

    registerPart(key, container, stretchAxis, "inner");
  }));

  // After everything is in place, normalize overlay size to a convenient unit
  normalizeFrameToView();
  onResize(); // set initial stretch
  animate();
}

// Fit the whole assembled frame to a normalized size in view space
function normalizeFrameToView() {
  // Compute bbox of the whole frame at current transforms
  const frameBBox = new THREE.Box3().setFromObject(frameGroup);
  const size = new THREE.Vector3(); frameBBox.getSize(size);
  const maxDim = Math.max(size.x, size.y);
  // We want the outer frame to occupy, say, 95% of min(viewportWidth, viewportHeight) at frameDistance.
  // Convert a desired NDC span to actual scale:
  const desiredViewportSpan = 0.92; // 92% of the shorter dimension
  // For a perspective camera, size on screen depends on distance and fov.
  const vFOV = THREE.MathUtils.degToRad(camera.fov);
  const viewHeightAtDist = 2 * Math.tan(vFOV/2) * frameDistance;
  const viewWidthAtDist = viewHeightAtDist * camera.aspect;
  const targetWorldSpan = Math.min(viewWidthAtDist, viewHeightAtDist) * desiredViewportSpan;

  const scaleFactor = (targetWorldSpan / maxDim);
  frameGroup.scale.setScalar(scaleFactor);
  frameGroup.updateMatrixWorld(true);

  // Recompute base bbox for every part after normalization
  for (const k in parts) {
    parts[k].bbox = getWorldBBox(parts[k].object);
    parts[k].basePos.copy(parts[k].object.position);
    parts[k].baseScale.copy(parts[k].object.scale);
  }
}

// Choose the “designed opening” aspect. Change to your intended inner opening ratio.
const targetInnerAspect = 16/9;

// Stretch logic on resize
function applyResponsiveStretch() {
  // Compute current viewport aspect vs target opening aspect
  const viewAspect = renderer.domElement.clientWidth / renderer.domElement.clientHeight;

  // Reset expanders to base first
  for (const k of [...horizontalExpanderKeys, ...verticalExpanderKeys]) {
    const p = parts[k];
    if (!p) continue;
    p.object.scale.copy(p.baseScale);
    p.object.position.copy(p.basePos);
  }

  // How much extra do we need along each axis?
  // We’ll linearly scale expander length along its axis so that the inner opening matches the viewport aspect:
  // If view is wider than target -> add width using *horizontal* expanders.
  // If view is taller than target -> add height using *vertical* expanders.
  const widen = viewAspect > targetInnerAspect;

  if (widen) {
    // Compute required horizontal scale factor relative to the original designed width.
    // Simple approach: scale each horizontal expander uniformly to achieve needed extra width.
    const scaleFactor = viewAspect / targetInnerAspect; // > 1
    for (const k of horizontalExpanderKeys) {
      const p = parts[k];
      if (!p) continue;
      const obj = p.object;
      // Stretch along X
      const s = p.baseScale.clone();
      s.x *= scaleFactor;
      obj.scale.copy(s);

      // Seam-lock: move so the inner seam stays fixed (grow outward).
      seamLockAlongAxis(p, "x", scaleFactor);
    }
  } else if (viewAspect < targetInnerAspect) {
    const scaleFactor = (targetInnerAspect / viewAspect); // > 1 needed vertically
    for (const k of verticalExpanderKeys) {
      const p = parts[k];
      if (!p) continue;
      const obj = p.object;
      // Stretch along Y
      const s = p.baseScale.clone();
      s.y *= scaleFactor;
      obj.scale.copy(s);

      // Seam-lock along Y
      seamLockAlongAxis(p, "y", scaleFactor);
    }
  }
  // Corners and mains remain untouched
}

// Keep the inner seam fixed while scaling outward.
// We use the part’s bbox to figure out which half should stay anchored.
// Heuristic: for top/bottom horizontal expanders, the inner seam is the side closer to X=0.
// For left/right vertical expanders, inner seam is the side closer to Y=0.
function seamLockAlongAxis(part, axis, scaleFactor) {
  if (scaleFactor === 1) return;

  const obj = part.object;
  obj.updateMatrixWorld(true);
  const bbox = new THREE.Box3().setFromObject(obj);
  const center = bbox.getCenter(new THREE.Vector3());
  const size = bbox.getSize(new THREE.Vector3());

  // Base values before scaling (approx from stored base bbox)
  const baseBBox = part.bbox;
  const baseCenter = baseBBox.getCenter(new THREE.Vector3());
  const baseSize = baseBBox.getSize(new THREE.Vector3());

  // Determine which side is “inner” (nearer to axis=0 in local/world)
  // Since everything is built around world origin ~ (0,0,0) when assembled, using world makes sense.
  const innerSign = (() => {
    if (axis === "x") {
      // If this expander sits on the left, its outer side is negative X; inner seam nearer X=0 => bbox.max.x < 0 means left
      return Math.abs(baseBBox.min.x) < Math.abs(baseBBox.max.x) ? -1 : 1;
    } else {
      // axis === "y"
      return Math.abs(baseBBox.min.y) < Math.abs(baseBBox.max.y) ? -1 : 1;
    }
  })();

  // Amount of half-extension added by scaling: Δ = (scaleFactor - 1) * 0.5 * baseLength
  const baseLen = axis === "x" ? baseSize.x : baseSize.y;
  const delta = (scaleFactor - 1) * 0.5 * baseLen;

  // Move the object by delta along axis so the inner edge (toward the origin) stays put and the outer edge grows.
  if (axis === "x") {
    obj.position.x += innerSign * delta;
  } else {
    obj.position.y += innerSign * delta;
  }
}

// Resize handling
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  // Keep the frame overlay scaled to view size
  normalizeFrameToView();
  applyResponsiveStretch();
}

window.addEventListener("resize", onResize);

// Basic orbit so you can see the world move while the frame stays locked
// (Optional) remove if you don’t want controls.
import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

function animate() {
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

loadAll();

</script>
</body>
</html>
